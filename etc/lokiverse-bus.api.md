## API Report File for "@lokiverse/bus"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { createClient } from 'redis';
import { createCluster } from 'redis';
import { RedisClientOptions } from 'redis';
import { RedisClusterOptions } from 'redis';

// @public
export interface Bus {
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    publish<T extends Serializable>(channel: string, data: T): Promise<void>;
    subscribe<T extends Serializable>(channel: string, handler: MessageHandler<T>): Promise<void>;
    unsubscribe(channel: string, handler?: MessageHandler): Promise<void>;
}

// @public
export class BusManager<T extends Record<string, BusOptions>> {
    constructor(config: BusManagerConfig<T>);
    publish<D extends Serializable>(channel: string, data: D): Promise<void>;
    start<K extends keyof T>(name?: K): Promise<void>;
    stop<K extends keyof T>(name?: K): Promise<void>;
    subscribe<D extends Serializable>(channel: string, handler: MessageHandler<D>): Promise<void>;
    unsubscribe(channel: string, handler?: MessageHandler): Promise<void>;
    use<K extends keyof T>(name?: K): Bus;
}

// @public
export interface BusManagerConfig<T extends Record<string, BusOptions>> {
    default?: keyof T;
    telemetry?: BusTelemetry;
    transports: T;
}

// @public
export interface BusOptions {
    codec?: CodecOption;
    maxPayloadSize?: number;
    middleware?: MiddlewareConfig;
    onHandlerError?: (channel: string, error: Error) => void;
    telemetry?: BusTelemetry;
    transport: Transport;
}

// @public
export interface BusTelemetry {
    onError?: (event: ErrorEvent) => void | Promise<void>;
    onHandlerExecution?: (event: HandlerExecutionEvent) => void | Promise<void>;
    onPublish?: (event: PublishEvent) => void | Promise<void>;
    onSubscribe?: (event: SubscribeEvent) => void | Promise<void>;
    onUnsubscribe?: (event: UnsubscribeEvent) => void | Promise<void>;
}

// @public
export interface Codec {
    decode<T extends Serializable>(data: TransportData): T;
    encode<T extends Serializable>(data: T): TransportData;
    readonly name: string;
}

// @public
export class CodecError extends Error {
    constructor(message: string, code?: CodecErrorCode, options?: ErrorOptions & {
        context?: CodecErrorContext;
    });
    readonly code: CodecErrorCode;
    readonly context?: CodecErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        code: CodecErrorCode;
        context: CodecErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export const CodecErrorCode: {
    readonly CODEC_ERROR: "CODEC_ERROR";
    readonly ENCODE_FAILED: "ENCODE_FAILED";
    readonly DECODE_FAILED: "DECODE_FAILED";
    readonly INVALID_CODEC: "INVALID_CODEC";
    readonly PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE";
};

// @public
export type CodecErrorCode = (typeof CodecErrorCode)[keyof typeof CodecErrorCode];

// @public
export interface CodecErrorContext {
    [key: string]: unknown;
    codec?: string;
    operation?: 'encode' | 'decode';
}

// @public
export type CodecOption = CodecType | Codec;

// @public
export type CodecType = 'json' | 'msgpack' | 'base64';

// @public
export interface Compression {
    compress(data: TransportData): Promise<TransportData>;
    decompress(data: TransportData): Promise<TransportData>;
    readonly name: string;
}

// @public
export class CompressionError extends Error {
    constructor(message: string, code?: CompressionErrorCode, options?: ErrorOptions & {
        context?: CompressionErrorContext;
    });
    readonly code: CompressionErrorCode;
    readonly context?: CompressionErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        code: CompressionErrorCode;
        context: CompressionErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export const CompressionErrorCode: {
    readonly COMPRESSION_FAILED: "COMPRESSION_FAILED";
    readonly DECOMPRESSION_FAILED: "DECOMPRESSION_FAILED";
    readonly INVALID_DATA: "INVALID_DATA";
    readonly UNKNOWN_FORMAT: "UNKNOWN_FORMAT";
    readonly INVALID_CONFIG: "INVALID_CONFIG";
};

// @public
export type CompressionErrorCode = (typeof CompressionErrorCode)[keyof typeof CompressionErrorCode];

// @public
export interface CompressionErrorContext {
    [key: string]: unknown;
    actualFormat?: string | number;
    algorithm?: string;
    expectedFormat?: string | number;
    field?: string;
    operation?: 'compress' | 'decompress' | 'detect';
}

// @public
export type CompressionOption = CompressionType | GzipConfig | Compression | boolean;

// @public
export type CompressionType = 'gzip';

// @public
export class DeadLetterError extends Error {
    constructor(message: string, options?: ErrorOptions & {
        context?: RetryErrorContext;
    });
    readonly context?: RetryErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        context: RetryErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export interface ErrorEvent {
    channel?: string;
    context?: Record<string, unknown>;
    error: Error;
    operation: 'publish' | 'subscribe' | 'unsubscribe' | 'decode' | 'handler';
    timestamp: number;
}

// @public
export const exponentialBackoff: RetryBackoff;

// @public
export const fibonacciBackoff: RetryBackoff;

// @public
export type GzipConfig = {
    type: 'gzip';
    level?: number;
    threshold?: number;
} | {
    level?: number;
    threshold?: number;
};

// @public
export interface HandlerExecutionEvent {
    channel: string;
    duration: number;
    error?: Error;
    success: boolean;
    timestamp: number;
}

// @public
export interface HMACConfig {
    key: string | Buffer;
    // (undocumented)
    type: 'hmac';
}

// @public
export interface Integrity {
    readonly name: string;
    sign(data: TransportData): TransportData;
    verify(data: TransportData): TransportData;
}

// @public
export class IntegrityConfigError extends IntegrityError {
    constructor(message: string, options?: {
        context?: IntegrityErrorContext;
        cause?: Error;
    });
}

// @public
export class IntegrityError extends Error {
    constructor(message: string, code: IntegrityErrorCode, options?: {
        context?: IntegrityErrorContext;
        cause?: Error;
    });
    // (undocumented)
    readonly code: IntegrityErrorCode;
    // (undocumented)
    readonly context?: IntegrityErrorContext;
}

// @public
export enum IntegrityErrorCode {
    INVALID_CONFIG = "INVALID_CONFIG",
    INVALID_DATA = "INVALID_DATA",
    SIGN_FAILED = "SIGN_FAILED",
    VERIFICATION_FAILED = "VERIFICATION_FAILED"
}

// @public
export interface IntegrityErrorContext {
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    algorithm?: string;
    // (undocumented)
    operation?: 'sign' | 'verify';
}

// @public
export type IntegrityOption = HMACConfig;

// @public
export class IntegritySecurityError extends IntegrityError {
    constructor(message: string, options?: {
        context?: IntegrityErrorContext;
        cause?: Error;
    });
}

// @public
export type IntegrityType = 'hmac';

// @public
export const linearBackoff: RetryBackoff;

// @public (undocumented)
export function memory(): MemoryTransport;

// @public (undocumented)
export class MemoryTransport implements Transport {
    // (undocumented)
    connect(): Promise<void>;
    // (undocumented)
    disconnect(): Promise<void>;
    // (undocumented)
    readonly name = "memory";
    // (undocumented)
    onReconnect(_callback: () => void): void;
    // (undocumented)
    publish(channel: string, data: TransportData): Promise<void>;
    // (undocumented)
    subscribe(channel: string, handler: TransportMessageHandler): Promise<void>;
    // (undocumented)
    unsubscribe(channel: string): Promise<void>;
}

// @public
export class MessageBus implements Bus {
    constructor(options: BusOptions);
    // (undocumented)
    connect(): Promise<void>;
    // (undocumented)
    disconnect(): Promise<void>;
    // (undocumented)
    publish<T extends Serializable>(channel: string, data: T): Promise<void>;
    // (undocumented)
    subscribe<T extends Serializable>(channel: string, handler: MessageHandler<T>): Promise<void>;
    // (undocumented)
    unsubscribe(channel: string, handler?: MessageHandler): Promise<void>;
}

// @public
export type MessageHandler<T = Serializable> = (data: T) => void | Promise<void>;

// @public
export interface Middleware extends Transport {
    readonly transport: Transport;
}

// @public
export interface MiddlewareConfig {
    compression?: CompressionOption | false;
    integrity?: IntegrityOption | false;
    retry?: RetryConfig | false;
}

// @public
export type OnDeadLetterCallback = (channel: string, data: TransportData, error: Error, attempts: number) => void | Promise<void>;

// @public
export type OnRetryCallback = (channel: string, data: TransportData, attempt: number) => void | Promise<void>;

// @public
export interface PublishEvent {
    channel: string;
    codecUsed: string;
    duration?: number;
    payloadSize: number;
    timestamp: number;
}

// @public
export function redis(config?: RedisTransportConfig | RedisTransportExternalConfig): RedisTransport;

// @public
export type RedisInstance = ReturnType<typeof createClient> | ReturnType<typeof createCluster>;

// @public
export class RedisTransport implements Transport {
    constructor(config?: RedisTransportConfig | RedisTransportExternalConfig);
    // (undocumented)
    connect(): Promise<void>;
    // (undocumented)
    disconnect(): Promise<void>;
    // (undocumented)
    readonly name = "redis";
    // (undocumented)
    onReconnect(callback: () => void): void;
    // (undocumented)
    publish(channel: string, data: TransportData): Promise<void>;
    // (undocumented)
    subscribe(channel: string, handler: TransportMessageHandler): Promise<void>;
    // (undocumented)
    unsubscribe(channel: string): Promise<void>;
}

// @public
export type RedisTransportConfig = RedisClientOptions | RedisClusterOptions;

// @public
export interface RedisTransportExternalConfig {
    // (undocumented)
    client: RedisInstance;
}

// @public
export type RetryBackoff = (attempt: number, baseDelayMs: number) => number;

// @public (undocumented)
export type RetryConfig = false | true | number | RetryConfigObject;

// @public
export interface RetryConfigObject {
    backoff?: 'exponential' | 'linear' | 'fibonacci' | RetryBackoff;
    delay?: number;
    maxAttempts?: number;
    onDeadLetter?: OnDeadLetterCallback;
    onRetry?: OnRetryCallback;
}

// @public
export interface RetryErrorContext {
    [key: string]: unknown;
    attempts?: number;
    channel?: string;
    maxAttempts?: number;
    operation?: 'retry';
}

// @public
export type Serializable = SerializablePrimitive | SerializableObject | Serializable[];

// @public (undocumented)
export interface SerializableObject {
    // (undocumented)
    [key: string]: Serializable | undefined;
}

// @public (undocumented)
export type SerializablePrimitive = string | number | boolean | null;

// @public
export interface SubscribeEvent {
    channel: string;
    handlerCount: number;
    timestamp: number;
}

// @public
export interface Transport {
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    readonly name: string;
    onReconnect(callback: () => Promise<void> | void): void;
    publish(channel: string, data: TransportData): Promise<void>;
    subscribe(channel: string, handler: TransportMessageHandler): Promise<void>;
    unsubscribe(channel: string): Promise<void>;
}

// @public (undocumented)
export type TransportData = Uint8Array;

// @public
export class TransportError extends Error {
    constructor(message: string, code?: TransportErrorCode, options?: ErrorOptions & {
        context?: TransportErrorContext;
    });
    // (undocumented)
    readonly code: TransportErrorCode;
    // (undocumented)
    readonly context?: TransportErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        code: TransportErrorCode;
        context: TransportErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export const TransportErrorCode: {
    readonly TRANSPORT_ERROR: "TRANSPORT_ERROR";
    readonly CONNECTION_FAILED: "CONNECTION_FAILED";
    readonly NOT_READY: "NOT_READY";
    readonly PUBLISH_FAILED: "PUBLISH_FAILED";
    readonly SUBSCRIBE_FAILED: "SUBSCRIBE_FAILED";
    readonly UNSUBSCRIBE_FAILED: "UNSUBSCRIBE_FAILED";
};

// @public (undocumented)
export type TransportErrorCode = (typeof TransportErrorCode)[keyof typeof TransportErrorCode];

// @public
export interface TransportErrorContext {
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    channel?: string;
    // (undocumented)
    operation?: TransportOperation;
    // (undocumented)
    retryable?: boolean;
    // (undocumented)
    transport?: string;
}

// @public (undocumented)
export type TransportMessageHandler = (data: TransportData) => void | Promise<void>;

// @public
export const TransportOperation: {
    readonly CONNECT: "connect";
    readonly DISCONNECT: "disconnect";
    readonly PUBLISH: "publish";
    readonly SUBSCRIBE: "subscribe";
    readonly UNSUBSCRIBE: "unsubscribe";
};

// @public (undocumented)
export type TransportOperation = (typeof TransportOperation)[keyof typeof TransportOperation];

// @public
export interface UnsubscribeEvent {
    channel: string;
    handlerCount: number;
    timestamp: number;
}

// @public
export const withJitter: (backoff: RetryBackoff, jitterFactor?: number) => RetryBackoff;

// @public
export const withMaxDelay: (backoff: RetryBackoff, maxDelayMs: number) => RetryBackoff;

// (No @packageDocumentation comment for this package)

```
