## API Report File for "@lokiverse/bus"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { createClient } from 'redis';
import { createCluster } from 'redis';
import { RedisClientOptions } from 'redis';
import { RedisClusterOptions } from 'redis';

// @public
export interface Bus {
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    publish<T extends Serializable>(channel: string, data: T): Promise<void>;
    subscribe<T extends Serializable>(channel: string, handler: MessageHandler<T>): Promise<void>;
    unsubscribe(channel: string, handler?: MessageHandler): Promise<void>;
}

// @public
export class BusConfigError extends BusError {
    constructor(message: string, options?: ErrorOptions & {
        context?: BusErrorContext;
    });
}

// @public
export class BusError extends Error {
    constructor(message: string, code?: BusErrorCode, options?: ErrorOptions & {
        context?: BusErrorContext;
    });
    readonly code: BusErrorCode;
    readonly context?: BusErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        code: BusErrorCode;
        context: BusErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export const BusErrorCode: {
    readonly BUS_ERROR: "BUS_ERROR";
    readonly NOT_CONNECTED: "NOT_CONNECTED";
    readonly INVALID_CONFIG: "INVALID_CONFIG";
    readonly HANDLER_FAILED: "HANDLER_FAILED";
    readonly TRANSPORT_FAILED: "TRANSPORT_FAILED";
    readonly CHANNEL_ERROR: "CHANNEL_ERROR";
};

// @public (undocumented)
export type BusErrorCode = (typeof BusErrorCode)[keyof typeof BusErrorCode];

// @public
export interface BusErrorContext {
    [key: string]: unknown;
    channel?: string;
    connected?: boolean;
    operation?: string;
    transport?: string;
}

// @public
export class BusManager<T extends Record<string, BusOptions>> {
    constructor(config: BusManagerConfig<T>);
    publish<D extends Serializable>(channel: string, data: D): Promise<void>;
    start<K extends keyof T>(name?: K): Promise<void>;
    stop<K extends keyof T>(name?: K): Promise<void>;
    subscribe<D extends Serializable>(channel: string, handler: MessageHandler<D>): Promise<void>;
    unsubscribe(channel: string, handler?: MessageHandler): Promise<void>;
    use<K extends keyof T>(name?: K): Bus;
}

// @public
export interface BusManagerConfig<T extends Record<string, BusOptions>> {
    default?: keyof T;
    transports: T;
}

// @public
export interface BusOptions {
    codec?: CodecOption;
    middleware?: MiddlewareConfig;
    onHandlerError?: (channel: string, error: Error) => void;
    transport: Transport;
}

// @public
export interface Codec {
    decode<T extends Serializable>(data: TransportData): T;
    encode<T extends Serializable>(data: T): TransportData;
    readonly name: string;
}

// @public
export class CodecError extends Error {
    constructor(message: string, code?: CodecErrorCode, options?: ErrorOptions & {
        context?: CodecErrorContext;
    });
    readonly code: CodecErrorCode;
    readonly context?: CodecErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        code: CodecErrorCode;
        context: CodecErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export const CodecErrorCode: {
    readonly CODEC_ERROR: "CODEC_ERROR";
    readonly ENCODE_FAILED: "ENCODE_FAILED";
    readonly DECODE_FAILED: "DECODE_FAILED";
    readonly INVALID_CODEC: "INVALID_CODEC";
};

// @public (undocumented)
export type CodecErrorCode = (typeof CodecErrorCode)[keyof typeof CodecErrorCode];

// @public
export interface CodecErrorContext {
    [key: string]: unknown;
    codec?: string;
    operation?: 'encode' | 'decode';
}

// @public (undocumented)
export type CodecOption = CodecType | Codec;

// @public (undocumented)
export type CodecType = 'json' | 'msgpack';

// @public
export const compose: (...fns: MiddlewareWrapper[]) => MiddlewareWrapper;

// @public
export const composeMiddleware: (baseTransport: Transport, config?: MiddlewareConfig) => Transport;

// @public
export interface Compression {
    compress(data: TransportData): Promise<Uint8Array>;
    decompress(data: Uint8Array): Promise<Uint8Array>;
    readonly name: string;
}

// @public
export class CompressionError extends Error {
    constructor(message: string, code?: CompressionErrorCode, options?: ErrorOptions & {
        context?: CompressionErrorContext;
    });
    readonly code: CompressionErrorCode;
    readonly context?: CompressionErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        code: CompressionErrorCode;
        context: CompressionErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export const CompressionErrorCode: {
    readonly COMPRESSION_FAILED: "COMPRESSION_FAILED";
    readonly DECOMPRESSION_FAILED: "DECOMPRESSION_FAILED";
    readonly INVALID_DATA: "INVALID_DATA";
    readonly UNKNOWN_FORMAT: "UNKNOWN_FORMAT";
    readonly INVALID_CONFIG: "INVALID_CONFIG";
};

// @public (undocumented)
export type CompressionErrorCode = (typeof CompressionErrorCode)[keyof typeof CompressionErrorCode];

// @public
export interface CompressionErrorContext {
    [key: string]: unknown;
    actualFormat?: string | number;
    algorithm?: string;
    expectedFormat?: string | number;
    field?: string;
    operation?: 'compress' | 'decompress' | 'detect';
}

// @public (undocumented)
export type CompressionOption = CompressionType | GzipConfig | Compression | boolean;

// @public (undocumented)
export type CompressionType = 'gzip';

// @public
export class DeadLetterError extends QueueError {
    constructor(message: string, options?: ErrorOptions & {
        context?: QueueErrorContext;
    });
}

// @public
export interface Encryption {
    decrypt(data: Uint8Array): Uint8Array;
    encrypt(data: TransportData): Uint8Array;
    readonly name: string;
}

// @public
export class EncryptionError extends Error {
    constructor(message: string, code?: EncryptionErrorCode, options?: ErrorOptions & {
        context?: EncryptionErrorContext;
    });
    // (undocumented)
    readonly code: EncryptionErrorCode;
    // (undocumented)
    readonly context?: EncryptionErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        code: EncryptionErrorCode;
        context: EncryptionErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export const EncryptionErrorCode: {
    readonly INVALID_CONFIG: "INVALID_CONFIG";
    readonly ENCRYPTION_FAILED: "ENCRYPTION_FAILED";
    readonly DECRYPTION_FAILED: "DECRYPTION_FAILED";
    readonly INVALID_DATA: "INVALID_DATA";
    readonly AUTHENTICATION_FAILED: "AUTHENTICATION_FAILED";
};

// @public (undocumented)
export type EncryptionErrorCode = (typeof EncryptionErrorCode)[keyof typeof EncryptionErrorCode];

// @public
export interface EncryptionErrorContext {
    [key: string]: unknown;
    algorithm?: string;
    field?: string;
    operation?: 'encrypt' | 'decrypt' | 'verify' | 'derive';
}

// @public (undocumented)
export type EncryptionOption = EncryptionType | HMACConfig | Encryption;

// @public (undocumented)
export type EncryptionType = 'base64' | 'hmac';

// @public
export const exponentialBackoff: RetryBackoff;

// @public
export const fibonacciBackoff: RetryBackoff;

// @public (undocumented)
export type GzipConfig = {
    type: 'gzip';
    level?: number;
    threshold?: number;
} | {
    level?: number;
    threshold?: number;
};

// @public (undocumented)
export interface HMACConfig {
    // (undocumented)
    key: Buffer | string;
    // (undocumented)
    type: 'hmac';
}

// @public
export const linearBackoff: RetryBackoff;

// @public (undocumented)
export function memory(): MemoryTransport;

// @public (undocumented)
export class MemoryTransport implements Transport {
    // (undocumented)
    connect(): Promise<void>;
    // (undocumented)
    disconnect(): Promise<void>;
    // (undocumented)
    readonly name = "memory";
    // (undocumented)
    onReconnect(_callback: () => void): void;
    // (undocumented)
    publish(channel: string, data: TransportData): Promise<void>;
    // (undocumented)
    subscribe(channel: string, handler: TransportMessageHandler): Promise<void>;
    // (undocumented)
    unsubscribe(channel: string): Promise<void>;
}

// @public (undocumented)
export class MessageBus implements Bus {
    constructor(options: BusOptions);
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    publish<T extends Serializable>(channel: string, data: T): Promise<void>;
    subscribe<T extends Serializable>(channel: string, handler: MessageHandler<T>): Promise<void>;
    unsubscribe(channel: string, handler?: MessageHandler): Promise<void>;
}

// @public
export type MessageHandler<T = Serializable> = (data: T) => void | Promise<void>;

// @public
export interface Middleware extends Transport {
    readonly transport: Transport;
}

// @public
export interface MiddlewareConfig {
    compression?: CompressionOption | false;
    encryption?: EncryptionOption | false;
    retry?: RetryConfig | false;
}

// @public
export type MiddlewareWrapper = (transport: Transport) => Transport;

// @public
export type OnDeadLetterCallback = (channel: string, data: TransportData, error: Error, attempts: number) => void | Promise<void>;

// @public
export type OnRetryCallback = (channel: string, data: TransportData, attempt: number) => void | Promise<void>;

// @public
export const pipe: <T>(value: T, ...fns: Array<(arg: T) => T>) => T;

// @public
export class QueueError extends Error {
    constructor(message: string, code?: QueueErrorCode, options?: ErrorOptions & {
        context?: QueueErrorContext;
    });
    readonly code: QueueErrorCode;
    readonly context?: QueueErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        code: QueueErrorCode;
        context: QueueErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export const QueueErrorCode: {
    readonly QUEUE_ERROR: "QUEUE_ERROR";
    readonly QUEUE_FULL: "QUEUE_FULL";
    readonly DEAD_LETTER: "DEAD_LETTER";
    readonly INVALID_CONFIG: "INVALID_CONFIG";
    readonly PROCESSING_TIMEOUT: "PROCESSING_TIMEOUT";
};

// @public (undocumented)
export type QueueErrorCode = (typeof QueueErrorCode)[keyof typeof QueueErrorCode];

// @public
export interface QueueErrorContext {
    [key: string]: unknown;
    attempts?: number;
    channel?: string;
    currentSize?: number;
    maxAttempts?: number;
    maxSize?: number;
    operation?: 'enqueue' | 'dequeue' | 'process' | 'retry';
}

// @public
export function redis(config?: RedisTransportConfig | RedisTransportExternalConfig): RedisTransport;

// @public
export type RedisInstance = ReturnType<typeof createClient> | ReturnType<typeof createCluster>;

// @public
export class RedisTransport implements Transport {
    constructor(config?: RedisTransportConfig | RedisTransportExternalConfig);
    // (undocumented)
    connect(): Promise<void>;
    // (undocumented)
    disconnect(): Promise<void>;
    // (undocumented)
    readonly name = "redis";
    // (undocumented)
    onReconnect(callback: () => void): void;
    // (undocumented)
    publish(channel: string, data: TransportData): Promise<void>;
    // (undocumented)
    subscribe(channel: string, handler: TransportMessageHandler): Promise<void>;
    // (undocumented)
    unsubscribe(channel: string): Promise<void>;
}

// @public
export type RedisTransportConfig = RedisClientOptions | RedisClusterOptions;

// @public
export interface RedisTransportExternalConfig {
    // (undocumented)
    client: RedisInstance;
}

// @public
export type RetryBackoff = (attempt: number, baseDelayMs: number) => number;

// @public (undocumented)
export type RetryConfig = false | true | number | RetryConfigObject;

// @public
export interface RetryConfigObject {
    backoff?: 'exponential' | 'linear' | 'fibonacci' | RetryBackoff;
    delay?: number;
    maxAttempts?: number;
    onDeadLetter?: OnDeadLetterCallback;
    onRetry?: OnRetryCallback;
    queue?: RetryQueueConfig;
}

// @public
export interface RetryQueueConfig {
    concurrency?: number;
    intervalMs?: number;
    maxSize?: number;
    removeDuplicates?: boolean;
}

// @public
export type Serializable = SerializablePrimitive | SerializableObject | Serializable[];

// @public (undocumented)
export interface SerializableObject {
    // (undocumented)
    [key: string]: Serializable | undefined;
}

// @public (undocumented)
export type SerializablePrimitive = string | number | boolean | null;

// @public
export interface Transport {
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    readonly name: string;
    onReconnect(callback: () => Promise<void> | void): void;
    publish(channel: string, data: TransportData): Promise<void>;
    subscribe(channel: string, handler: TransportMessageHandler): Promise<void>;
    unsubscribe(channel: string): Promise<void>;
}

// @public (undocumented)
export type TransportData = Uint8Array;

// @public
export class TransportError extends Error {
    constructor(message: string, code?: TransportErrorCode, options?: ErrorOptions & {
        context?: TransportErrorContext;
    });
    // (undocumented)
    readonly code: TransportErrorCode;
    // (undocumented)
    readonly context?: TransportErrorContext;
    // @internal (undocumented)
    toJSON(): {
        name: string;
        message: string;
        code: TransportErrorCode;
        context: TransportErrorContext | undefined;
        stack: string | undefined;
    };
}

// @public
export const TransportErrorCode: {
    readonly TRANSPORT_ERROR: "TRANSPORT_ERROR";
    readonly CONNECTION_FAILED: "CONNECTION_FAILED";
    readonly NOT_READY: "NOT_READY";
    readonly PUBLISH_FAILED: "PUBLISH_FAILED";
    readonly SUBSCRIBE_FAILED: "SUBSCRIBE_FAILED";
    readonly UNSUBSCRIBE_FAILED: "UNSUBSCRIBE_FAILED";
};

// @public (undocumented)
export type TransportErrorCode = (typeof TransportErrorCode)[keyof typeof TransportErrorCode];

// @public
export interface TransportErrorContext {
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    channel?: string;
    // (undocumented)
    operation?: TransportOperation;
    // (undocumented)
    retryable?: boolean;
    // (undocumented)
    transport?: string;
}

// @public (undocumented)
export type TransportMessageHandler = (data: TransportData) => void | Promise<void>;

// @public
export const TransportOperation: {
    readonly CONNECT: "connect";
    readonly DISCONNECT: "disconnect";
    readonly PUBLISH: "publish";
    readonly SUBSCRIBE: "subscribe";
    readonly UNSUBSCRIBE: "unsubscribe";
};

// @public (undocumented)
export type TransportOperation = (typeof TransportOperation)[keyof typeof TransportOperation];

// @public
export const withCompression: (compression: CompressionOption) => MiddlewareWrapper;

// @public
export const withEncryption: (encryption: EncryptionOption) => MiddlewareWrapper;

// @public
export const withJitter: (backoff: RetryBackoff, jitterFactor?: number) => RetryBackoff;

// @public
export const withMaxDelay: (backoff: RetryBackoff, maxDelayMs: number) => RetryBackoff;

// @public
export const withRetry: (config: RetryConfig) => MiddlewareWrapper;

// (No @packageDocumentation comment for this package)

```
